---
title: "lab 2"
author: "Adam Michalski"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, echo = TRUE)
```

```{r}
library(DescTools)
wzrost <- read.csv2('wzrost.csv', header=FALSE)
colnames(wzrost) <- c('dane')
quantile(wzrost$dane, probs =c(0.25, 0.5, 0.75))
mean(wzrost$dane)
t.test(wzrost$dane, conf.level = 0.9)
var(wzrost$dane)
VarCI(wzrost$dane, method = "classic", conf.level = 0.9, sides = "two.sided")
```

```{r}
formula1 <- read.csv2('Formula1.csv', header=FALSE)
colnames(formula1) <- c('dane')
n <- length(formula1$dane)
average_speed <- n/(sum(1/formula1$dane))
average_speed
```

```{r}
kosci <- read.csv2('Kosci.csv', header=FALSE)
colnames(kosci) <- c('dane')
n <- length(kosci$dane)
naive_average <- sum(kosci$dane)/n
naive_average
average_dimention <- (sum(kosci$dane^3)/n)^(1/3)
average_dimention
difference <- average_dimention-naive_average
difference
kosci_sd <- (sd(kosci$dane^3))^(1/3)
kosci_sd
average_used_amber <- average_dimention^3
average_used_amber
```

```{r}
library(readxl)
df <- read_excel('Wyksz_Zarobki.xls')
srednie_wartosci_zarobkow <- c(0, seq(500, 10000, by=1000), 15000)
srednie_wartosci_zarobkow
df_median <- quantile(srednie_wartosci_zarobkow[df$Zarobki], probs =c(0.5))
df_median
```

```{r}
pu_test <- function(n, mu, sigma, level){
  normal_sample <- rnorm(n, mu, sigma)
  test_value <- t.test(normal_sample, alternative = "two.sided", mu = mu, conf.level = level)
  if (test_value$conf.int[1] <= mu & mu <= test_value$conf.int[2])
    TRUE
  else
    FALSE
}
eksperyment <- replicate(1000, pu_test(100, 0, 1, 0.9))
ilosc_poprawnych_wyników <- sum(eksperyment)
ilosc_poprawnych_wyników
```

```{r}
CovrgPlot <-
  function(marg, scal=log(2*marg[3]^2), lev=0.95,
           alim = 4, intpts = 1, plotCI=1:4)  {
    ## plotCI= set of integer indices of 4 CI coverage curves to plot
    #  plot is restricted to alpha in interval in (-alim, alim)
    #  parameter intpts controls the number of points used
    #    to plot curves (more, for larger intpts)
    ## step 0 the vector of alpha values to use as evaluation points

    # no need to call these packages here as they are included under Import of Description file
    # require(BiasedUrn)
    # require(reshape)
    # require(ggplot2)
    # require(plyr)
    # require(cowplot)

    mA=marg[1]; mB=marg[2]; N=marg[3]
    if(length(intersect(c(mA,mB), c(0,N))))
      return("Degenerate co-occurrence distribution!")
    xrng = c(max(0, mA+mB-N), min(mA,mB))
    xn = xrng[2]-xrng[1]+1
    avec0L = avec0U = numeric(xn)
    avec0L[1] = -log(2*marg[3]^2) ; avec0U[xn] = log(2*marg[3]^2)
    avec0U[1] = MinX.Int(marg, scal=scal, lev=lev)[2]
    avec0L[xn] = MinX.Int(marg, scal=scal, lev=lev)[1]
    for(x in 2:(xn-1)) {
      avec0L[x] = EHypQuInt(x+xrng[1]-1, marg, (1+lev)/2, scal=scal)[1]
      avec0U[x] = EHypQuInt(x+xrng[1]-1, marg, (1-lev)/2, scal=scal)[1] }
    avec = sort(union(round(avec0L,4), round(avec0U,4)))
    ## add at least intpts extra equally spaced points between all the points
    avec = bvec = avec[abs(avec)<alim+0.5]
    for(j in 2:length(avec)) bvec = c(bvec, seq(avec[j-1],avec[j],
                                                length=intpts+2))
    avec = sort(unique(bvec))
    an = length(avec)
    ## step 1 the array of CIs
    arrCI = array(0, c(xn,4,2))
    minx = xrng[1]-1
    for(k in 2:(xn-1)) {
      tmp = AlphInts(k+minx,marg,scal=scal, lev=lev)
      arrCI[k,,] = rbind(tmp$CI.CP, tmp$CI.Blaker,
                         tmp$CI.midQ, tmp$CI.midP) }
    ## special case for X = xrng[1] or xrng[2]
    arrCI[1,,] = rep(1,4) %o% MinX.Int(marg, scal=scal, lev=(1+lev)/2)
    arrCI[xn,,] = rep(1,4) %o% MaxX.Int(marg, scal=scal, lev=(1+lev)/2)
    ## step 2 array of coverage indicators times prob's
    covCI = array(0, c(an, xn,4))
    for(j in 1:4) for(k in 1:an) for(b in 1:xn) covCI[k,b,j] =
      (avec[k] >= arrCI[b,j,1] & avec[k] <= arrCI[b,j,2])*
      BiasedUrn::dFNCHypergeo(minx+b,mA,N-mA,mB,exp(avec[k]))
    ## step 3 coverage prob's
    covPrb = array(0, c(an,4))
    for(j in 1:4) covPrb[,j] = c(covCI[,,j] %*% rep(1,xn))




    covPrbDF <- data.frame(cbind(avec, covPrb))
    colnames(covPrbDF) <- c("avec","Clopper-Pearson CI","Blaker CI","MidQ CI", "MidP CI")

    # subset the data for the selected CIs
    head(covPrbDF)
    covPrbDF <- covPrbDF[, c(1,(plotCI+1))]
    head(covPrbDF)

    covPrbmelt <- reshape::melt(covPrbDF, id=c("avec"))

    # prepare line plot
    # ----------------------
    value <- variable <- NULL #added to prevent no visible binding note
    lp <- ggplot2::ggplot(covPrbmelt, aes(x=avec, y=value, group=variable)) +
      ggplot2::geom_line(aes(color=variable)) +
      ggplot2::geom_point(aes(color=variable)) +
      ggplot2::geom_hline(yintercept = lev, color="black", linetype="dashed") +
      ggplot2::facet_grid(variable ~ ., switch = "y") +
      ggplot2::theme(legend.position = "none") +
      ggplot2::xlab("Alpha MLE") + ggplot2::ylab(paste0("True coverage probability by the ", lev*100, "% confidence interval"))



    # prepare histogram plot
    # ---------------------------

    tmp <- covPrbmelt
    tmp$abovethr[tmp$value >= lev] <- "yes"
    tmp$belowthr[tmp$value < lev] <- "yes"

    abovethr <- belowthr <- aboveperc <- belowperc <- legendtext <- NULL #added to prevent no visible binding note
    # count <- plyr::ddply(tmp, .(variable), summarize,
    count <- plyr::ddply(tmp, "variable", plyr::summarize,
                         above = length(abovethr[!is.na(abovethr)]),
                         below = length(belowthr[!is.na(belowthr)]))

    count$all <- count$above+count$below
    count$aboveperc <- count$above/count$all*100
    count$belowperc <- count$below/count$all*100

    hp <- ggplot2::ggplot(covPrbmelt, aes(x=value))+
      ggplot2::geom_histogram(aes(fill=variable), color="white")+
      ggplot2::facet_grid(variable ~ .) +
      ggplot2::geom_vline(xintercept = lev, color="black", linetype="dashed") +
      ggplot2::theme(legend.position = "none") +
      ggplot2::xlab("Alpha MLE") + ggplot2::ylab("Count")

    # sometimes, e.g., when requesting just Blaker, all histogram mass can fall above threshold (lev) and histogram print of 0% for less than lev
    # is cut off. for that situation, extend the xlim by a bit to show the printing of 0%
    if(min(covPrbmelt$value) >= lev) {
      hp <- hp + ggplot2::xlim((lev-0.005), max(ggplot2::ggplot_build(hp)$data[[1]]$xmax))
    }



    # find the maximum of the count values plotted on y axis of histogram, to find location to print percentage
    maxcount <- max(ggplot2::ggplot_build(hp)$data[[1]]$count)
    hp <- hp +
      ggplot2::geom_text(data = count, aes(x = lev,  y = maxcount*0.95, label = paste0(round(aboveperc, 1), "%")), vjust = 0.5, hjust = -0.25, size=3) +
      ggplot2::geom_text(data = count, aes(x = lev,  y = maxcount*0.95, label = paste0(round(belowperc, 1), "%")), vjust = 0.5, hjust = 1.25, size=3)

    # add threshold in the first lineplot
    thresholdlegend <- data.frame(cbind(count[,1, drop=FALSE], legendtext=NA))
    thresholdlegend$legendtext[1] <- paste0("true coverage probability of ", round(lev*100, 2), "% threshold")

    lp <- lp +
      ggplot2::geom_text(data = thresholdlegend, aes(x = 0,  y = lev, label = legendtext), hjust = 0.5, vjust = 1.5, size=3)


    list(covPrbDF, covPrbmelt, lev)

    # plot grid of both line plot and histogram
    finalplot <- cowplot::plot_grid(lp, hp, align = "h", ncol = 2, rel_widths = c(2/3, 1/3))
    print(finalplot)

  }

CovrgPlot(
  marg = c(50,70,150), lev = 0.95)
```